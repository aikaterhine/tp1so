/////////////////////////////////////////////////////////////////////
//////////IDEIA SOBRE COMO ORGANIZAR AS PRIORIDADES DESTE TP/////////
////////////////////////////////////////////////////////////////////
MUTEX                            --> bloqueia um recurso compartilhado(pedaço de código. Pode ser função, variável, um while...)

DEADLOCK DESTE TP                --> A precisa usar um recurso compartilhado de B, que precisa de um recurso compartilhado de C, que precisa de um recurso compartilhado de A.

O QUE TODO MUNDO QUER SABER?     --> Se, na hora que ela quiser usar o forno, ela pode.

PRESSUPOSTO                      --> Todo personagem(menos o Kripke) precisa de seu próprio recurso compartilhado que informa seu interesse no                                      forno, pois este recurso será usado por pelo menos 2 threads, a do personagem em questão e a do personagem                                      que quer saber se o primeiro está querendo usar o forno.

COMO FAZER?                      --> Criamos uma variável booleana para cada personagem(menos o Kripke) indicando se foi cumprida ou não. Para cada                                      uma destas variáveis booleanas, criamos um MUTEX(e um COND para variáveis que potencialmente serão acessadas                                        por várias threads) para que elas possam ser acessadas por uma thread por vez.


USO DO MUTEX NAS VARIAVEIS BOOL:

- Primeiro de tudo ao usar wait da COND, é recomendado um loop while para conferir se as mudanças esperadas aconteceram(por causa de um fenômeno chamado "spurious wakeups", que tem relação com a implementação do wait).

  STUART:

    contexto: preciso saber se sheldon, howard ou leonard querem usar o forno.
    //Estes locks servem para os casos onde aconteceu um unlock, mas a variável booleana está true
    /*Quando que isso acontece? Exemplo: Kripke checa se sheldon, howard ou leonard estão usando o forno. Para isto ele precisou trancar as             variáveis booleanas --> Em algum momento ele vai destrancar essas variáveis, maaaaas ele não mudou a variável booleana --> Ao destrancar,     esses locks abaixo vão sair do bloqueio em que estão e trancar as variáveis de novo.*/
    /*DETALHE: Pq Kripke não mandou sinal para a variável COND? Porque ele não mudou o valor da variável booleana(a COND serve para mudanças de           estado...pelo menos nesse contexto)*/
    
    lock(sheldon_quer_usar)
    lock(howard_quer_usar)
    lock(leonard_quer_usar)
    //este while, ifs e waits, servem para quando houve o envio do sinal, pq a variável bool mudou o estado(de false, que era o padrão, para true)
    while(sheldon_quer_usar or howard_quer_usar or leonard_quer_usar){//se, no momento desta verificação, nenhum dos 3 quer usar, sai do loop
      if(sheldon_quer_usar)
        pthread_cond_wait()

      if(howard_quer_usar)
        pthread_cond_wait()

      if(leonard_quer_usar)
        pthread_cond_wait()
    }

  printf("AGORA EU POSSO USAR UHUUUUUUUUL!!!!!!");
//trancaria o forno
//lembrar de dar unlock nas variáveis após fazer as ações


CONCLUSÃO: Não precisa de uma fila para definir a ordem de uso!! A lógica para todos os personagens é semelhante, envolve checar se alguem(ou vários alguens) está querendo usar o forno e, caso contrário, só vai!
